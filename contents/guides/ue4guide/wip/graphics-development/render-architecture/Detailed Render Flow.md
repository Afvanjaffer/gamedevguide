The start of Deferred Rendering is

Engine / Source / Runtime / Renderer / Private / DeferredShadingRenderer.cpp (532)

FDeferredShadingSceneRenderer :: Render ()

It starts from here.

<table><thead><tr class="header"><th><strong>Number of lines</strong></th><th><strong>Code piece</strong></th><th><strong>Contents</strong></th></tr></thead><tbody><tr class="odd"><td>539</td><td>GRenderTargetPool.TransitionTargetsWritable ()</td><td>Transition to the state where the target of the target pool can be drawn</td></tr><tr class="even"><td>542</td><td>SceneContext.ReleaseSceneColor ()</td><td>Release scene color buffer</td></tr><tr class="odd"><td>546 to 552</td><td>FRHICommandListExecutor :: WaitOnRHIThreadFence ()</td><td>If RHI is running in a separate thread, wait for OcculusionSubmittedFence here Wait for completion of the OcculusionCulling process of the previous stage?</td></tr><tr class="even"><td>568</td><td>GSystemTextures.InitializeTextures ()</td><td>Initialization of system texture Nothing is done if initialized</td></tr><tr class="odd"><td>571</td><td>SceneContext.Allocate ()</td><td><p>Secure the buffer for the render target matching the ViewFamily</p><p>Information on whether ViewFamily has FeatureLevel or SceneCapture</p></td></tr><tr class="even"><td>573</td><td>SceneContext.AllocDummyGBufferTargets ()</td><td>Assign dummy black texture to GBuffer</td></tr><tr class="odd"><td>579</td><td>InitViews ()</td><td>Various initialization of view About crawling of transformation meshes, translucent sorting, initialization of shadow and write cash</td></tr><tr class="even"><td>581-588</td><td>PostInitViewFamily_RenderThread () etc.</td><td>Unimplemented</td></tr><tr class="odd"><td>599 to 606</td><td>GetEyeAdaptation ()</td><td>It is meaningless because it calls the const function but it does not store the acquired one?</td></tr><tr class="even"><td>608 to 631</td><td>if (ShouldPrepareDistanceFieldScene ())</td><td>This block becomes effective when the DistanceField system (AO, Shadow, etc.) is used However, IntelHD 4000 series seems to fail to generate 3D texture, and processing contents which are forcibly invalidated are required for DF technology Creation, update, etc. of Volume texture aligned in View space</td></tr><tr class="odd"><td>720 to 727</td><td>FGlobalDynamicVertexBuffer :: Get (). Commit ()</td><td>Commit processing of dynamic vertex buffer and index buffer Mainly unlock vertices and index buffers for particles (unmapped)</td></tr><tr class="even"><td>732 to 737</td><td>Scene-&gt; FXSystem-&gt; PreRender ()</td><td><p>Preprocessing rendering effects</p><p>It is not done here if planar reflection mainly for updating <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/GPU&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgyX2gWM99vexm97pQFPReU9GnmeA">GPU</a> particles is effective or render thread is effective</p></td></tr><tr class="odd"><td>767 to 788</td><td>RenderPrePass ()</td><td>Performing Z Pre-Pass <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a></td></tr><tr class="even"><td>807</td><td>SceneContext.ResolveSceneDepthTexture ()</td><td>Deployment of <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">resolve</a> compression depth of depth buffer rendered with Z Pre-Pass and <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">resolve</a> processing of MSAA</td></tr><tr class="odd"><td>811</td><td>ComputeLightGrid ()</td><td>From the computational shader code of the light grid, it is mainly for semi-transparent Forward Rendering which is generating light link list for Clusterd lighting</td></tr><tr class="even"><td>821 - 826</td><td>SceneContext.AllocGBufferTargets ()</td><td>Memory allocation for GBuffer</td></tr><tr class="odd"><td>830 - 841</td><td>RenderOcclusion ()</td><td><p>Occlusion related <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a></p><p>We also create a hierarchical depth buffer here, such as occlusion queries for low resolution buffers</p><p>It is effective when Z Pre-Pass draws everything in the depth buffer</p><p>When parallel processing of SSAO is performed, processing starts here</p></td></tr><tr class="even"><td>845 to 849</td><td>RenderShadowDepthMaps ()</td><td>Draw shadow map <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">Render</a> it to an atlased shadow map unlike in the past</td></tr><tr class="odd"><td>852 to 857</td><td>ClearLPVs ()</td><td>Clear the buffer used for Light Propagation Volume</td></tr><tr class="even"><td>859 to 863</td><td>RenderCustomDepthPassAtLocation ()</td><td><p>Draw CustomDepth before base pass</p><p>If you set 0 in r.CustomDepth.Order, draw at this stage</p><p>It can be used in the DBuffer path</p></td></tr><tr class="odd"><td>865 to 868</td><td>ComputeVolumetricFog ()</td><td>In order to apply volume fog, only one parallel light source that lights space-divided 3D texture (probably) corresponds to light function</td></tr><tr class="even"><td>870 - 878</td><td>RenderForwardShadingShadowProjections ()</td><td><p>Project shadow on scene in case of Forward Rendering</p><p>In Forward, it is difficult to process multiple shadows at the time of material calculation, so calculate the shadow attenuation in a pure white buffer called a white buffer</p></td></tr><tr class="odd"><td>885 to 900</td><td>if (bDBuffer)</td><td>Draw Deferred Decal when DBuffer is enabled</td></tr><tr class="even"><td>902 to 934</td><td>AllocateDeferredShadingPathRenderTargets ()</td><td>Secure render target for Deferred shading Depending on conditions, clear GBuffer and volume write buffer for translucency</td></tr><tr class="odd"><td>936 to 946</td><td>BeginRenderingGBuffer ()</td><td><p>Render target setting</p><p><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EF%25A5%25A4%25A5%25E4%25A1%25BC%25A5%25D5%25A5%25EC%25A1%25BC%25A5%25E0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgBXPi-IwnreW5jRJhRRBVjEsTt3Q">For wire frame</a> display, use MSAA buffer</p></td></tr><tr class="even"><td>951 to 958</td><td>RenderBasePass ()</td><td>Drawing the base path <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">Resolving the</a> depth buffer after the end of the base pass which seems to be loading commands in parallel by multiple threads</td></tr><tr class="odd"><td>976 to 985</td><td>ClearGBufferAtMaxZ ()</td><td>Clear GBuffer of unpainted part Usually it is not necessary, but for GBuffer display correspondence?</td></tr><tr class="even"><td>987</td><td>VisualizeVolumetricLightmap ()</td><td>Visualization of volume light map</td></tr><tr class="odd"><td>989</td><td>ResolveSceneDepthToAuxiliaryTexture ()</td><td><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">Resolve</a> the depth buffer to another buffer Depth Test for hardware that can not be fetched while testing</td></tr><tr class="even"><td>991 to 1002</td><td>RenderOcclusion ()</td><td><p>Occlusion drawing after base pass</p><p>If <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> is not done at line 830, <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> here</p></td></tr><tr class="odd"><td>1012 to 1017</td><td>RenderShadowDepthMaps ()</td><td>Draw shadow map and volume fog If the occlusion drawing is after the base pass, do it here</td></tr><tr class="even"><td>1019 to 1023</td><td>RenderCustomDepthPassAtLocation ()</td><td>Custom depth drawing after base pass Normally it will be drawn here</td></tr><tr class="odd"><td>1028 to 1038</td><td>FXSystem-&gt; PostRenderOpaque ()</td><td>Effect drawing after base pass Maintenance of <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/GPU&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgyX2gWM99vexm97pQFPReU9GnmeA">GPU</a> particles taking a collision judgment is done</td></tr><tr class="even"><td>1042 to 1054</td><td>RenderVelocities ()</td><td>Draw speed buffer</td></tr><tr class="odd"><td>1057</td><td>CopyStencilToLightingChannelTexture ()</td><td>Copy the write channel information written to the stencil buffer</td></tr><tr class="even"><td>1059 to 1061</td><td>GfxWaitForAsyncSSAO ()</td><td>Wait for <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> of parallel processing SSAO</td></tr><tr class="odd"><td>1065 to 1081</td><td>ProcessAfterBasePass ()</td><td>Post process after base pass If unprocessed yet, perform Deferred Decal or SSAO processing</td></tr><tr class="even"><td>1084 to 1101</td><td>SetRenderTargetsAndClear ()</td><td>Clear stencil buffer only</td></tr><tr class="odd"><td>1111 to 1114</td><td>RenderIndirectCapsuleShadows ()</td><td><p>Indirect lighting calculation by capsule shadow</p><p>Multiplication with SceneColor and SSAO At this stage, SceneColor should have the base pass emissivity written</p></td></tr><tr class="even"><td>1118</td><td>RenderDFAOAsIndirectShadowing ()</td><td>We also calculate the vent normal for the drawing of DistanceFieldAO, and then use it in several stages</td></tr><tr class="odd"><td>1121 to 1124</td><td>ClearTranslucentVolumeLighting ()</td><td>Clear the translucent volume light</td></tr><tr class="even"><td>1127</td><td>RenderLights ()</td><td><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">Rendering</a> lights</td></tr></tbody></table>

From here we enter the RenderLights () function once.

[[The source code]](https://translate.googleusercontent.com/translate_c?act=url&depth=1&hl=en&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=en&u=http://d.hatena.ne.jp/keyword/%25A5%25BD%25A1%25BC%25A5%25B9%25A5%25B3%25A1%25BC%25A5%25C9&xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&usg=ALkJrhgsLGggT0knWgrxkExVtCxrr1EIRQ) is below.

Engine / Source / Runtime / Renderer / Private / LightRendering.cpp (316)

<table><thead><tr class="header"><th><strong>Number of lines</strong></th><th><strong>Code piece</strong></th><th><strong>Contents</strong></th></tr></thead><tbody><tr class="odd"><td>329 - 332</td><td>GatherSimpleLights ()</td><td>Collect particle light as SimpleLight Mainly for tile based lighting</td></tr><tr class="even"><td>340 to 365</td><td>LightSceneInfo-&gt; ShouldRenderLight ()</td><td>Create a list of lights to draw</td></tr><tr class="odd"><td>368 to 375</td><td>SortedLights.Sort ()</td><td>Sort the light with shadow, with light function etc.</td></tr><tr class="even"><td>420 to 424</td><td>WaitComputeFence (TranslucencyLightingVolumeClearEndFence)</td><td>Wait for asynchronous execution of translucent write volume</td></tr><tr class="odd"><td>435 to 455</td><td>RenderTiledDeferredLighting ()</td><td>Perform tile-based Deferred Lighting</td></tr><tr class="even"><td>457-461</td><td>RenderSimpleLightsStandardDeferred ()</td><td>If tile-based <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> that <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">renders</a> SimpleLight is executed, <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> here is not performed</td></tr><tr class="odd"><td>463-478</td><td>RenderLight ()</td><td><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">Render</a> with light without shadows, no light function</td></tr><tr class="even"><td>480 - 495</td><td>InjectTranslucentVolumeLightingArray ()</td><td>Draw shadowless light, SimpleLight on translucent light volume 1 Write 1 for each slice with geometry shader Draw with DrawCall</td></tr><tr class="odd"><td>499 to 559</td><td>UpdateLPVs ()</td><td><p>When LPV is valid, update LPV</p><p>Reflective Shadow Maps and direct light into the volume</p></td></tr><tr class="even"><td>569</td><td>for (int32 LightIndex = AttenuationLightStart; ...</td><td>From here shadowed or / and processing with light with write function</td></tr><tr class="odd"><td>592 to 631</td><td>RenderShadowProjections ()</td><td>Shadow rendering shadow attenuation to the white buffer is not performed at lighting calculation but once drawn in the white buffer of the same size as the <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25D5%25A5%25EC%25A1%25BC%25A5%25E0%25A5%25D0%25A5%25C3%25A5%25D5%25A5%25A1&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhisF24A0q9KyESpTXGmRFovHW_YXg">frame buffer</a> It also draws to translucent volume light and height map light</td></tr><tr class="even"><td>633 to 637</td><td>HeightfieldLightingViewInfo.ComputeLighting ()</td><td>Heightfield lighting calculation Heightfield only Lighting results are <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendered</a> to an atlas texture</td></tr><tr class="odd"><td>640 to 657</td><td>RenderPreviewShadowsIndicator ()</td><td>Draw attenuation by write function in white buffer</td></tr><tr class="even"><td>659 to 662</td><td>CopyToResolveTarget ()</td><td>White buffer <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">resolve</a></td></tr><tr class="odd"><td>664 to 669</td><td>InjectTranslucentVolumeLighting ()</td><td>If the shadow is not valid, <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">render</a> to the semitransparent light volume here</td></tr><tr class="even"><td>674 to 677</td><td>RenderLight ()</td><td>Direct <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering of</a> lights</td></tr></tbody></table>

Light [[rendering]](https://translate.googleusercontent.com/translate_c?act=url&depth=1&hl=en&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=en&u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA) is here.

After that we will return to DeferredShadingRenderer.cpp again.

<table><thead><tr class="header"><th><strong>Number of lines</strong></th><th><strong>Code piece</strong></th><th><strong>Contents</strong></th></tr></thead><tbody><tr class="odd"><td>1133</td><td>InjectAmbientCubemapTranslucentVolumeLighting ()</td><td>Render Ambient CubeMap to translucent light volume</td></tr><tr class="even"><td>1137</td><td>FilterTranslucentVolumeLighting ()</td><td><p>Filtering translucent light volume</p><p>3 x 3 x 3 box filter</p></td></tr><tr class="odd"><td>1142 to 1153</td><td>ProcessLpvIndirect ()</td><td>Post process process after lighting Currently only LPV application</td></tr><tr class="even"><td>1155</td><td>RenderDynamicSkyLighting ()</td><td>Drawing dynamic skylights</td></tr><tr class="odd"><td>1159</td><td>ResolveSceneColor ()</td><td><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25BE%25A5%25EB&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhj_SY3TAOps2QqBhjU1NXSAIgUSPw">Resolve</a> the target of the SceneColor drawn so far Usually, you use the resolve command of RHI, but if mobile emulation is required special processing</td></tr><tr class="even"><td>1162</td><td>RenderDeferredReflections ()</td><td><p>Apply environmental reflection as post process</p><p>Also calculate Screen Space Reflection here</p></td></tr><tr class="odd"><td>1169 to 1173</td><td>ProcessAfterLighting ()</td><td>Post process after applying reflection Currently only post process processing of Screen Space Subsurface Scattering</td></tr><tr class="even"><td>1180 to 1185</td><td>RenderLightShaftOcclusion ()</td><td>Drawing shielding information on the light shaft Although you can activate the light shaft without this, there is a difference in quality when there is a shielding near the camera</td></tr><tr class="odd"><td>1188 to 1212</td><td>RenderAtmosphere ()</td><td>Drawing Atomospheric Fog</td></tr><tr class="even"><td>1217 to 1222</td><td>RenderFog ()</td><td>Drawing volume fog of Height Fog is also applied here</td></tr><tr class="odd"><td>1224 to 1236</td><td>RenderPostOpaqueExtensions ()</td><td><p>Additional processing after opaque rendering is like a <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> process that the user can specify in <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/C%252B%252B&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhh7SsyKGVpy_h3_lCNWZkUOEr2zYQ">C ++</a> ?</p><p>It seems that you can also Dispatch ComputeShader</p></td></tr><tr class="even"><td>1252 to 1261</td><td>RenderTranslucency ()</td><td><p>Draw translucent objects</p><p>In case of Separate Translucency, draw it in another buffer and do it until composition</p></td></tr><tr class="odd"><td>1267 to 1275</td><td>RenderDistortion ()</td><td>Drawing material with Refraction enabled</td></tr><tr class="even"><td>1280 to 1286</td><td>RenderLightShaftBloom ()</td><td>Results differ depending on whether shielding information for drawing the light shaft is drawn or not</td></tr><tr class="odd"><td>1288 to 1293</td><td>RenderOverlayExtensions ()</td><td><p>Perhaps user-executable <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25C0%25A5%25EA%25A5%25F3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhb5KI9lLSPo7I7DPWru8OyvaEkYA">rendering</a> passes</p><p>Like RenderPostOpaqueExtensions</p></td></tr><tr class="even"><td>1295 to 1303</td><td>RenderDistanceFieldLighting ()</td><td>DistanceField type lighting processing (GI etc.)</td></tr><tr class="odd"><td>1306 to 1318</td><td><p>RenderMeshDistanceFieldVisualization ()</p><p>RenderStationaryLightOverlap ()</p></td><td>Information for <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25C7%25A5%25D0%25A5%25C3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhjRP4aT6LWm-QHg1c81HcrbvFh4Gg">debugging</a> Information on visualized mesh DF and StationaryLight overlap information</td></tr><tr class="even"><td>1336 to 1341</td><td>GPostProcessing.Process ()</td><td>Drawing post process</td></tr><tr class="odd"><td>1361 to 1366</td><td>RenderFinish ()</td><td><p>Drawing end processing</p><p><a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25C7%25A5%25D0%25A5%25C3%25A5%25B0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhjRP4aT6LWm-QHg1c81HcrbvFh4Gg">Debug</a> visualization etc.</p></td></tr></tbody></table>

that's all.

From here it is a post process.

Engine / Source / Runtime / Renderer / Private / PostProcess / PostProcessing.cpp (1262) From this location.

<table><thead><tr class="header"><th><strong>Number of lines</strong></th><th><strong>Code piece</strong></th><th><strong>Contents</strong></th></tr></thead><tbody><tr class="odd"><td>1385 to 1451</td><td><p>AddPostProcessDepthOfFieldGaussian ()</p><p>AddPostProcessDepthOfFieldCircle ()</p><p>AddPostProcessDepthOfFieldBokeh ()</p></td><td><p>Drawing of <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25C8%25EF%25BC%25CC%25B3%25A6%25BF%25BC%25C5%25D9&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhjhfayqBtFibKA6urZcPh3aPyE2Lw">depth of field</a> (DoF)</p><p>In the case of BokehDoF, synthesis with the Separate Translucency buffer is also done here</p></td></tr><tr class="even"><td>1453 - 1463</td><td>RegisterPass (new (FMemStack :: Get ()) FRCPassPostProcessBokehDOFRecombine (bIsComputePass))</td><td>If it is not BokehDoF, synthesize Separate Translucency here</td></tr><tr class="odd"><td>1465</td><td>AddPostProcessMaterial (Context, BL_BeforeTonemapping, SeparateTranslucency)</td><td>Apply post process material before tone map</td></tr><tr class="even"><td>1469 - 1482</td><td>AddTemporalAA ()</td><td>Apply TemporalAA</td></tr><tr class="odd"><td>1484 to 1544</td><td>FRCPassPostProcessMotionBlur ()</td><td><p>Apply motion blur</p><p>Using an improved version of [A Reconstruction Filter for Plausible Motion <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/Blur&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhh0afQIzaDchXcf0BoCcG6JXF91uQ">Blur</a> ] It is also possible to apply higher quality blur by 2-pass rendering using scale values ​​changed</p><p>If 1 is specified for r.MotionBlurSeparable it becomes valid</p></td></tr><tr class="even"><td>1546 to 1559</td><td>FRCPassPostProcessVisualizeMotionBlur ()</td><td>Visualization of motion blur and bloom</td></tr><tr class="odd"><td>1562 to 1572</td><td>FRCPassPostProcessDownsample ()</td><td>Downscaling the SceneColor buffer to a half resolution buffer</td></tr><tr class="even"><td>1574 to 1609</td><td>FRCPassPostProcessHistogram ()</td><td>Use the down-sampled SceneColor to obtain the <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25D2%25A5%25B9%25A5%25C8%25A5%25B0%25A5%25E9%25A5%25E0&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgqaoTpD_aDU2Z8ihjbW56uy1UvdA">histogram</a> of the screen</td></tr><tr class="odd"><td>1612 to 1625</td><td>CreateDownSampleArray ()</td><td><p>Perform multiple downsampling from the half resolution SceneColor for Bloom</p><p>If Eye Adaptation is enabled, set up in this</p></td></tr><tr class="even"><td>1628 to 1653</td><td><p>AddPostProcessBasicEyeAdaptation ()</p><p>AddPostProcessHistogramEyeAdaptation</p></td><td>If bloom which executes Eye Adaptation is invalid, it downsamples here</td></tr><tr class="odd"><td>1655 to 1756</td><td>AddBloom ()</td><td><p>Apply blooming</p><p>Also perform <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=en&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=http://d.hatena.ne.jp/keyword/%25A5%25EC%25A5%25F3%25A5%25BA%25A5%25D5%25A5%25EC%25A5%25A2&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhH2YC_vrLlpsvh92JD7BSoLD2N3A">lens flare</a> and lens blur in this function</p></td></tr><tr class="even"><td>1760 to 1790</td><td>AddTonemapper ()</td><td>Apply tone map</td></tr><tr class="odd"><td>1792 - 1795</td><td>AddPostProcessAA ()</td><td>Apply FXAA</td></tr><tr class="even"><td>1797-1804</td><td>FRCPassPostProcessVisualizeDOF ()</td><td>DoF Visualization</td></tr><tr class="odd"><td>1808 to 1823</td><td>AddGammaOnlyTonemapper ()</td><td>If it is not a full post process, apply Separate Translucency synthesis and simple tone mapper</td></tr><tr class="even"><td>1826 to 1906</td><td>FRCPassPostProcessVisualizeComplexity () etc.</td><td>Various visualization etc.</td></tr><tr class="odd"><td>1908</td><td>AddPostProcessMaterial (Context, BL_AfterTonemapping ...</td><td>Apply post-process material after tone map</td></tr><tr class="even"><td>1910-1982</td><td>FRCPassPostProcessSubsurfaceVisualize () etc.</td><td>Various visualization etc.</td></tr><tr class="odd"><td>1986 to 2025</td><td>FRCPassPostProcessUpscale ()</td><td>If the screen percentage is valid, upscale here</td></tr></tbody></table>

Or more.

Congratulations!

Normally, when you use [[UE 4]](https://translate.googleusercontent.com/translate_c?act=url&depth=1&hl=en&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=en&u=http://d.hatena.ne.jp/keyword/UE4&xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&usg=ALkJrhgx6ECYXWqumldTN9bSM9Ik1nB2yw) , you do not need to be conscious of the order of these paths, but you should read the [source code][the source code] if you really want to replace the processing, or want to avoid wasteful processing.

I hope this article will help such people.

_From &lt;<http://monsho.hatenablog.com/entry/2017/12/16/012502>&gt;_
